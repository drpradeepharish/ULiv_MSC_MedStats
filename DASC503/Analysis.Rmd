---
title: "R Notebook"
output: html_notebook
---

```{r}
library(multidplyr)
library(tidyverse)
library(readxl)
library(lubridate)
library(magrittr)
library(cowplot)
library(ggh4x)
library(epitools)
library(santoku)
library(patchwork)
```

# Study setup

## Define study time period

For this study, we will consider all events occuring anytime after the 1st of January 2014 till end of 31st of December 2020 as of interest. After examination of the structure of the data, we will also define age cutoffs to ensure we have sufficient data to support our observations.

```{r}

dateFrom = ymd_hms("2014-1-1 0:0:1")
dateTo = ymd_hms("2020-12-31 23:59:59")

intervalStudy <- interval(dateFrom,dateTo)

intAgeMin = 25
intAgeMax = 90

```

## Read in files

Incase of non-unique values for an individual in any variable, we assume the most frequently occuring value as the true value. For instance, if a patient who participated in 5 years of the study was an ex-smoker for all but one year (during which they smoked), the patient will be regarded as an ex-smoker.

```{r}

# Patient population data
tblData <- read_csv("Source/pop_snomed_assignment.csv")
# SNOMED codelist
tblLungCancerCodes <- read_csv("Source/dLungCancerCodes.csv")
  
#tblLungCancerCodes <- read_csv("https://raw.githubusercontent.com/annalhead    /CPRD_multimorbidity_codelists/9d26739d93744c8444aedbe10de65657c4af6bc0/codelists/Primary%20Malignancy_Lung.csv")

```

## Helper functions

```{r}
# Function to get the most frequently occurring value in a vector. 
fGetMostFrequent <- function(tblInput){
  tblInput %>% 
    table() %>% 
    sort(decreasing = TRUE) %>% 
    .[1] %>% 
    names() -> output
  return(output)
}

# Function to calculate the time difference in years between two dates
fCalcYear <- function(dateFrom,dateTo){
  return(interval(dateFrom, dateTo) / years(1))
}

# Function to save ggPlot
fSavePlot <-
  function(plot,
           title = NA,
           subtitle = NA,
           h = 8,
           w = 12,
           background = "white") {
    ggsave(
      plot,
      filename = paste0(title, subtitle, ".png"),
      path = "Figures/",
      device = "png",
      dpi = 800,
      width = w,
      height = h,
      units = "in",
      bg = background,
      create.dir = TRUE
    )
  }

# Function to calculate incidence and poission CI
fCalculateIncidence <- function(tblNumerator, tblDenominator, strGroupVars) 
  {
  tblNumerator %>%
    group_by(across(all_of(strGroupVars))) %>%
    summarise(diagnosed = sum(ever_diagnosed)) %>%
    left_join(
      tblDenominator %>%
        group_by(across(all_of(strGroupVars))) %>%
        summarise(patient_years = sum(total_patient_years))
    ) %>%
    mutate(
      Incidence = diagnosed / patient_years * 10000,
      CI = pois.approx(diagnosed, pt = patient_years) * 10000
    )
}

# Function to plot incidence and poission CI
fPlotIncidence <- function(tblData, strTitle, strGroupBy, strNameGroupBy, numCrudeGlobalIncidence, strSmooth, lstYLim = c(0,100)) {
  tblData %>% 
  ggplot(aes(
    x = ageband,
    y = Incidence,
    group = !!sym(strGroupBy),
    colour = !!sym(strGroupBy)
  )) +
    scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
    geom_hline(aes(yintercept = numCrudeGlobalIncidence)) +
    geom_errorbar(aes(ymin = CI$lower, ymax = CI$upper), width = 0.05, alpha = 0.2) +
    geom_point() +
    geom_smooth(method = strSmooth, se = FALSE) +
    ggsci::scale_color_aaas() +
    theme_cowplot(12) +
    ylab("Incidence rate per 10k person years") +
    xlab("Age") +
    coord_cartesian(ylim = lstYLim) +
    labs(colour = strNameGroupBy, title = strTitle)
}

fPlotBoxIncidence <- function(tblData, strX, strY, strTitle, strGroupBy, boolStaggerXLbl = TRUE, strSmooth, numCrudeGlobalIncidence, lstYLim = c(0,100)) {
  tblData %>% 
  ggplot(aes(
    x = !!sym(strX),
    y = !!sym(strY),
    group = !!sym(strGroupBy),
    colour = !!sym(strGroupBy)
  )) +
    {if(boolStaggerXLbl) scale_x_discrete(guide = guide_axis(n.dodge = 3))} +
    geom_hline(aes(yintercept = numCrudeGlobalIncidence)) +
    geom_errorbar(aes(ymin = CI$lower, ymax = CI$upper), width = 0.05, alpha = 0.2, show.legend = FALSE) +
    geom_boxplot(show.legend = FALSE) +
    ggsci::scale_color_aaas() +
    theme_cowplot(12) +
    ylab("Incidence rate per 10k person years") +
    xlab("") +
    coord_cartesian(ylim = lstYLim) +
    labs(title = strTitle)
}
```

# Data cleaning and transformation

## Data restructure

```{r}
tblData %<>%
  # Remove rows with missing SNOMED description IDs
  filter(!is.na(snomedctdescriptionid)) %>%
  mutate(
    # Convert date columns to Date objects
    event_date = ymd(event_date),
    dob = ymd(dob),
    
    # Identify cancer-relevant events
    is_cancer_relevant = ifelse(
      snomedctdescriptionid %in% tblLungCancerCodes$snomedctdescriptionid |
        medcodeid %in% tblLungCancerCodes$medcodeid,
      TRUE,
      FALSE
    ),
    
    # Identify death events
    is_death = ifelse(snomedctdescriptionid < 0, TRUE, FALSE),
    is_death_cancer = ifelse(snomedctdescriptionid == -5, TRUE, FALSE),
    
    # Determine the censor date
    censor_date = case_when(
      is_cancer_relevant == TRUE ~ event_date,
      is_death == TRUE ~ event_date,
      .default = dateTo # Default censor date if no event = end of study
    )
  ) 


```

## Parallel aggregation with `multidplyr`

```{r}
# Create a parallel processing cluster using available CPU cores
pllCluster <- new_cluster(parallel::detectCores() - 4)

# Distribute data across the cluster by patient ID
tblData %>%
  group_by(pid) %>%
  partition(pllCluster) -> pllDataSummary

# Load required libraries and functions on all cluster nodes
cluster_library(pllCluster, "tidyverse")
cluster_copy(pllCluster, c("fCalcYear", "fGetMostFrequent", "dateFrom"))

# Summarise data per patient across cluster nodes
pllDataSummary %>%
  summarise(
    # If non-unique values exist, get the most frequent values for
    sex = fGetMostFrequent(sex),
    qimd = fGetMostFrequent(qimd),
    ethnicity = fGetMostFrequent(ethnicity),
    sha = fGetMostFrequent(sha),
    smoking_status = fGetMostFrequent(smoking_status),
    dob = fGetMostFrequent(dob),
    
    # Check if ever diagnosed with cancer
    ever_diagnosed = max(is_cancer_relevant),
    
    # Check if patient ever died
    ever_died = max(is_death),
    
    # Check if death was cancer-related
    ever_died_cancer = max(is_death_cancer),
    
    # Get earliest date of event for a patient.
    censor_date = min(censor_date)
  ) %>%
  
  # Calculate patient age at event date, rounded down. We need this for age-specific incidence calculations
  mutate(age = fCalcYear(dob, censor_date) %>% floor()) %>%
  
  # Bring results back to the main R session
  collect() %>%
  
  # Remove patients who die of cancer, but are not diagnosed with cancer within available data. These patients would have likely contracted the disease earlier on, and as they already have the disease, they are not at risk. Also only keep events within study interval.
  filter(!(ever_diagnosed == 0 & ever_died_cancer == 1),
         censor_date %within% intervalStudy) %>% 
  
  # For some reason, lubridate breaks down when adding years to a leap year...possible bug? Anyway, this should round down the leap day to the previous day. Not an ideal solution, but given the average person-year length of the study, the contribution of a day shouldn't add up that much.. Christ this took ages to figure out whats happening.
  mutate(dob = gsub("02-29","02-28", dob)) -> tblDataSummary

```

# Numerator calculations

```{r}
# Filter patients diagnosed with cancer based on predefined cutoffs and discretise ages
tblDataSummary %>%
  filter(ever_diagnosed == 1,
         (age >= intAgeMin &
            age <= intAgeMax)) %>%
  mutate(ageband = chop_width(
    age,
    start = 25,
    width = 5,
    labels = lbl_discrete()
  )) -> tblNumerator

# Save the filtered dataset as a CSV file
tblNumerator %>% write_csv("tblNumerator.csv")

# Creating an empty tibble with no unique diagnoses of cancer to capture those years, sex, qimd, etc in which there are no diagnoses of cancer (incidence has been 0). As such, these data are filtered out in our numerator calculations. This will introduce it back in. This is so that we can plot those years with no incidences easily 
expand_grid(
  sex = unique(tblNumerator$sex) %>% as.character(),
  sha = unique(tblNumerator$sha) %>% as.character(),
  qimd = unique(tblNumerator$qimd) %>% as.character(),
  ethnicity = unique(tblNumerator$ethnicity) %>% as.character(),
  smoking_status = unique(tblNumerator$smoking_status) %>% as.character(),
  ageband = santoku::chop_width(
    seq(intAgeMin, intAgeMax, by = 5),
    start = 25,
    width = 5,
    labels = lbl_discrete()
  )
) %>%
  mutate(
    pid = 0,
    ever_diagnosed = 0,
    ever_died = 0,
    ever_died_cancer = 0,
    dob = NA,
    censor_date = NA,
    age = NA,
  ) %>%
  bind_rows(tblNumerator) -> tblGraphNumerator

```

# Denominator calculations

```{r}

#WARNING: This is ridiculously computationally expensive. The need to figure out each person's person-year calculation, per age creates a tibble with something like 3m rows. This can be done more efficiently, for instance by not calculating the py for every year, but merely the first year in the study and the year of censoring. 

# Create a parallel processing cluster using available CPU cores
pllCluster <- new_cluster(parallel::detectCores() - 4)

# Distribute data across the cluster by patient ID
tblDataSummary %>%
  group_by(pid) %>%
  partition(pllCluster) -> pllDataSummary

# Load required libraries and functions on all cluster nodes
cluster_library(pllCluster, "tidyverse")
cluster_copy(pllCluster, c("fCalcYear", "dateFrom"))

# We are now going to achieve two objectives with the next section. We are going to calculate all ages a person experienced in the study, and the total person- year they contributed to the study after taking into account their dob

# We initially calculate age at study start and censor date. Then we will create a new row for each age the patient experienced in the study. Eg. if a patient born on 2000 participates in the study from 2014 till 2018 then the patient will have been 14,15,16,17, and 18. This is important for age specific person year calculations as they will have contributed person years over a range of ages.



pllDataSummary %>%
  mutate(
    age_at_start = fCalcYear(dob, dateFrom) %>% floor(),
    age_at_censor = fCalcYear(dob, censor_date) %>% floor(),
    age_seq = map2(age_at_start, age_at_censor, seq)
  ) %>%
  collect() -> Temp

Temp %<>%
  unnest_longer(age_seq) #unnesting not implemented in multidplyr. So we have to exit out of multidplyr and reparallelise.

# While we have calculated the ages the patient contributed, we have to calculate the fractional person-years per age they took part in the study. Eg. a patient born on 2000-01-01 vs 2000-06-01 will have contributed different person years (by 6 months) at any point in the study. This approach takes their dob into account and calculates the correct factional person-years contributed.
Temp %<>%
  group_by(pid) %>%
  partition(pllCluster) %>%
  mutate(
    year_start = pmax(dateFrom, ymd(dob) + years(age_seq)),
    year_end = pmin(censor_date, ymd(dob) + years(age_seq + 1)),
    patient_years = fCalcYear(year_start, year_end)
  ) %>%
  collect() 

  # For the edge cases where the patient's birthday is after the censor date. The fraction of the year up to the censor date is correctly calculated in the previous row. However, the loop may generate an additional row for the next birthday, resulting in a negative 'patient_years' value because the interval extends past the censor date. This filter ensures only valid rows are kept by removing any where the calculated interval is invalid.

# Group by demographic and age attributes, then calculate total patient-years per group
Temp %>%
  filter(patient_years >= 0) %>% 
  group_by(sex, qimd, ethnicity, sha, smoking_status, age = age_seq) %>%
  summarise(total_patient_years = sum(patient_years, na.rm = TRUE)) %>% 
  arrange(age) %>%
  
  # Filtering here as we do not want to include at-risk times of people who are outside of the age cut-offs
  filter(age >= intAgeMin &
           age <= intAgeMax) %>%
  mutate(ageband = chop_width(
    age,
    start = 25,
    width = 5,
    labels = lbl_discrete()
  ))  -> tblDenominator

# Save the final aggregated denominator table to a CSV file
tblDenominator %>% write_csv("tblDenominator.csv")

# Clean variables
rm(Temp, pllCluster, pllDataSummary, tblData, tblLungCancerCodes)

numCrudeGlobalIncidence = sum(tblNumerator$ever_diagnosed)/sum(tblDenominator$total_patient_years) * 10000
```

# Assessment 1:

## Age and sex specific incidence rate ratios for lung cancer are higher men than women

```{r}

lstGroupVar = c("sex", "ageband")
ggVarGroupBy = "sex"
ggNameGroupBy = "Sex"
strGraphTitle = "SexAge"
strSmoother = "loess"


fCalculateIncidence(tblGraphNumerator,
                    tblDenominator,
                    lstGroupVar) %>% 
   mutate(sex = gsub("^men","Male", sex),
         sex = gsub("^women","Female", sex)) -> tblTemp


tblTemp %>% fPlotIncidence(
  strTitle = "Overall",
  strGroupBy = ggVarGroupBy,
  strNameGroupBy = ggNameGroupBy,
  strSmooth = strSmoother,
  numCrudeGlobalIncidence = numCrudeGlobalIncidence,
  lstYLim = c(0,75)
) -> ggTempAll

ggTempAll %>% fSavePlot(strGraphTitle,strSmoother, w = 6, h = 6)

```

## Age, sex and deprivation specific incidence rates for lung cancer are directly proportional to quintiled index of multiple deprivation

```{r}
lstGroupVar = c("qimd", "ageband")
ggVarGroupBy = "qimd"
ggNameGroupBy = "Qunitiled index of \nmultiple deprivation"
strGraphTitle = "AgeQIMD"
strSmoother = "loess"


fCalculateIncidence(
  tblGraphNumerator %>% filter(sex == "men"),
  tblDenominator %>% filter(sex == "men"),
  lstGroupVar
) -> tblTempMale

fCalculateIncidence(
  tblGraphNumerator %>% filter(sex == "women"),
  tblDenominator %>% filter(sex == "women"),
  lstGroupVar
) -> tblTempFemale

tblTempMale %>% fPlotIncidence(
  strTitle = "Male",
  strGroupBy = ggVarGroupBy,
  strNameGroupBy = ggNameGroupBy,
  strSmooth = strSmoother,
  numCrudeGlobalIncidence = numCrudeGlobalIncidence
) -> ggTempMale

tblTempFemale %>% fPlotIncidence(
  strTitle = "Female",
  strGroupBy = ggVarGroupBy,
  strNameGroupBy = ggNameGroupBy,
  strSmooth = strSmoother,
  numCrudeGlobalIncidence = numCrudeGlobalIncidence
) -> ggTempFemale

fCalculateIncidence(tblNumerator, tblDenominator, c("qimd")) %>% 
    fPlotBoxIncidence(strX = "qimd",
                    strY = "Incidence",
                    strTitle = "Deprivation",
                    strGroupBy = "qimd",
                    boolStaggerXLbl = FALSE, 
                    numCrudeGlobalIncidence =  numCrudeGlobalIncidence , 
                    lstYLim =  c(0,15)) -> ggTemp

ggFig <- ggTemp + ggTempMale + ggTempFemale + plot_layout(axes = "collect", axis_titles = "collect", guides = "collect") & theme(legend.position = 'bottom')

ggFig %>% fSavePlot(strGraphTitle,strSmoother, w = 14, h = 6)
```

## Age, sex and region specific incidence rates are higher in the north of England

```{r}

lstGroupVar = c("sha", "ageband")
ggVarGroupBy = "sha"
ggNameGroupBy = "Regions"
strGraphTitle = "AgeSha"
strSmoother = "loess"


fCalculateIncidence(
  tblGraphNumerator %>% filter(sex == "men"),
  tblDenominator %>% filter(sex == "men"),
  lstGroupVar
) -> tblTempMale

fCalculateIncidence(
  tblGraphNumerator %>% filter(sex == "women"),
  tblDenominator %>% filter(sex == "women"),
  lstGroupVar
) -> tblTempFemale

fCalculateIncidence(tblGraphNumerator,
                    tblDenominator,
                    lstGroupVar) -> tblTemp


tblTempMale %>% fPlotIncidence(
  strTitle = "Male",
  strGroupBy = ggVarGroupBy,
  strNameGroupBy = ggNameGroupBy,
  strSmooth = strSmoother,
  numCrudeGlobalIncidence = numCrudeGlobalIncidence
) -> ggTempMale

tblTempFemale %>% fPlotIncidence(
  strTitle = "Female",
  strGroupBy = ggVarGroupBy,
  strNameGroupBy = ggNameGroupBy,
  strSmooth = strSmoother,
  numCrudeGlobalIncidence = numCrudeGlobalIncidence
) -> ggTempFemale

fCalculateIncidence(tblNumerator, tblDenominator, c("sha")) %>% 
   mutate(sha = gsub("Yorkshire and the Humber", "Yorkshire \\& Humber", sha)) %>% 
  fPlotBoxIncidence(strX = "sha",
                    strY = "Incidence",
                    strTitle = "Regions",
                    strGroupBy = "sha",
                    boolStaggerXLbl = TRUE, 
                    numCrudeGlobalIncidence =  numCrudeGlobalIncidence , 
                    lstYLim =  c(0,15)) -> ggTemp

ggFig <- ggTemp + ggTempMale + ggTempFemale + plot_layout(axes = "collect", axis_titles = "collect", guides = "collect") & theme(legend.position = 'bottom')

ggFig %>% fSavePlot(strGraphTitle,strSmoother, w = 14, h = 6)
```

## Relation between deprivation and region

```{r}
tblDataSummary %>% 
  select(qimd, sha) %>% 
  table() %>% 
  as_tibble(rownames = "Region") %>% 
  group_by(sha) %>% 
  mutate(Percent = n/sum(n)*100,
         sha = gsub("Yorkshire and the Humber", "Yorkshire \\& Humber", sha)) -> ggTemp

ggTemp %>% 
  ggplot(aes(sha, qimd, fill = Percent)) +
  geom_tile() + 
  geom_text(aes(label = round(Percent, 1))) +
   ggsci::scale_fill_gsea(reverse = TRUE) +
   theme_cowplot(12) +
   scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  ylab("Qunitiled index of \nmultiple deprivation") +
  xlab("Regions") + 
  labs(fill = "Percent of \nparticipants \nper region")-> ggFig

ggFig %>% fSavePlot("RegionDeprivation","Htmp", w = 8, h = 6)

```

**Obtaining data from the ONS:**

Population estimates: <https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/estimatesofthepopulationforenglandandwales/mid2011tomid2022detailedtimeseries/myebtablesenglandwales20112022v3.xlsx>

Postcode directory: <https://www.arcgis.com/sharing/rest/content/items/6092bd9ef7b04f94982053610e6c0acc/data>

SHA names: <https://www.arcgis.com/sharing/rest/content/items/819941b6e37c4e07ab6fda56425bf9b1/data>

```{r}

lstCSV <- list.files(path = "Source/", pattern = "\\.csv$")

for (i in 1:length(lstCSV))
{
  assign(substr(lstCSV[i], 1, nchar(lstCSV[i]) - 4), read_csv(file = paste0("Source/",lstCSV[i])))
}

dLungCancerCodes <- read_csv("https://raw.githubusercontent.com/annalhead/CPRD_multimorbidity_codelists/9d26739d93744c8444aedbe10de65657c4af6bc0/codelists/Primary%20Malignancy_Lung.csv")

dPopEstimates20112022 <- read_excel("Source/myebtablesenglandwales20112022v3.xlsx", sheet = "MYEB1 (2023 Geography)", skip = 1)

ONSPD_NOV_2020_UK %>% 
  select(oslaua,oshlthau) %>% 
  unique() %>% 
  filter(oshlthau %in% SHA_names_and_codes_EN_as_at_12_10$SHA10CD) %>% 
  left_join(SHA_names_and_codes_EN_as_at_12_10, by = (c("oshlthau" = "SHA10CD"))) -> dONSPostcodes 

dPopEstimates20112022 %>% left_join(dONSPostcodes, by = c("ladcode23" = "oslaua")) %>%
  select(-c(ladcode23, laname23, oshlthau, country)) %>%
  filter(!is.na(SHA10NM)) %>% 
  group_by(SHA10NM, age, sex) %>% 
  summarise(across(starts_with("population"),sum)) -> dSumPopEstimates

rm(ONSPD_NOV_2020_UK, dPopEstimates20112022, dONSPostcodes, SHA_names_and_codes_EN_as_at_12_10)

pop_snomed_assignment %>% 
    filter(.$snomedctdescriptionid %in% dLungCancerCodes$snomedctdescriptionid | .$medcodeid %in% dLungCancerCodes$medcodeid) %>%
    group_by(pid) %>% 
    summarise(first_diagnosis = min(event_date)) %>% 
    filter(first_diagnosis %within% intervalStudy) %>% 
    .$pid %>% 
    unique() -> lstDiagnosedPatients 

pop_snomed_assignment %>% 
  filter(pid %in% lstDiagnosedPatients) %>% 
  mutate(age = interval(ymd(dob),ymd(event_date)) %/% years(1)) %>% 
  mutate(is_cancer_relevant = ifelse(snomedctdescriptionid %in% dLungCancerCodes$snomedctdescriptionid | medcodeid %in% dLungCancerCodes$medcodeid, "Y","N"),
         is_death = ifelse(snomedctdescriptionid <0,ifelse(snomedctdescriptionid == -5,"C","Y"),NA)) %>% 
  filter(event_date %within% intervalStudy) %>% 
  select(-c(snomedctdescriptionid, medcodeid))-> dDiagnosedPatients
  

```
